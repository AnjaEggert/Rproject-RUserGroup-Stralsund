---
title: "Cortisol, oxytocin and social challenges in pigs"
subtitle: "Part 1: cortisol & oxytocin"
author: "Liza R. Moscovice, Anja Eggert and Ulrike Gimsa"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: show
    toc: true
    toc_depth: 3
    toc_float: true
---

```{r setup, include=FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

# include = FALSE prevents code and results from appearing in the finished file, but code runs.
# echo = FALSE prevents code, but not the results from appearing in the finished file.
# message = FALSE prevents messages that are generated by code from appearing in the finished file.
# warning = FALSE prevents warnings that are generated by code from appearing in the finished.
```

```{r libraries}
library(knitr)
library(kableExtra)
library(tidyverse)
library(patchwork)   # to combine subplots
library(cowplot)     # to combine subplots
library(lme4)        # linear mixed model, no p values
#library(lmerTest)   # linear mixed model, with p values
library(performance) # model evaluation
library(emmeans)     # calculate emmeans + contrasts
library(multcomp)    # post-hoc letters 

source("./scripts/fe-re-tab.r")         # which random slopes to include, written by Roger Mundry
source("./scripts/glmm_stability.r")    # stability test, written by Roger Mundry
```

```{r theme}
my_theme = theme_classic() +
  theme(axis.title = element_text(face="bold", size=10),
        axis.text  = element_text(size=10, angle = 0, vjust = 0.5),
        plot.title = element_text(face="bold", size=10),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())

my_theme_poster = theme_classic() +
  theme(axis.title   = element_text(face="bold", size=18),
        axis.text    = element_text(size=18, angle = 0, vjust = 0.5),
        plot.title   = element_text(face="bold", size=20),
        legend.title = element_text(size=18), 
        legend.text  = element_text(size=18),
        legend.background = element_rect(fill=NA),
        legend.spacing.y  = unit(0.8, 'cm'),
        panel.grid.major  = element_blank(),
        panel.grid.minor  = element_blank())
```

# Data set

Here we read in the master data table `prosocial-pigs-hormones.csv` and make some adjustments of the data format.

* change from double to factor: `sow` and `group.order`
* change from character to ordered factor: `context` and `sex`
* change from character to date format: `date`
* create numeric decimal hours from time of day: `time.n`
* create z-transformed "scaled" time of day and age: `time.n.z` and `age.z`

```{r}
dat.horm <- read_csv(file = "./data/prosocial-pigs-hormones.csv")  

dat.horm <- dat.horm                                                    %>%
  mutate(sow      = factor(sow))                                        %>%
  mutate(sex      = factor(sex,
                           levels=c("f","m")))                          %>% 
  mutate(context  = factor(context,
                           levels=c("Baseline","Weaning","Play",
                                    "Separation","Reunion")))           %>% 
  mutate(date     = lubridate::ymd(date)) %>%
  mutate(time.n   = lubridate::hour(time) + lubridate::minute(time)/60) %>% 
  mutate(time.n.z = scale(time.n))                                      %>% 
  mutate(age.z    = scale(age))

# make separate columns of log-concentrations to feed directly into `fe.re.tab()`
dat.horm <- dat.horm %>% 
  mutate(cort_ngml_log = log(cort_ngml)) %>% 
  mutate(oxyt_pgml_log = log(oxyt_pgml))
```

\ 

# Variables used in the analyses

* Response variables:
  + cortisol concentration in ng per 1 ml salvia: `cort_ngml`
  + oxytocin concentration in pg per 1 ml salvia: `oxyt_pgml`

* Fixed test predictor:
  + social context (baseline, weaning, play, separation, reunion): `context`

* Fixed control predictors:
  + sex: `sex`
  + age as numeric and scaled covariate: `age.z` 
  + time of day as numeric and scaled covariate: `time.n.z`
  
* Random effects:
  + individual piglets nested within sow and within social group: `uniq.id` within `sow` within `uniq.group`
  + date: `date`
  
# Summary statistics

* Here we show the summary statistics for cortisol and oxytocin.

```{r}
sum.horm <- dat.horm %>% 
  group_by(context) %>% 
  summarise(across(
    .cols = c("cort_ngml", "oxyt_pgml"), 
    .fns = list(mean = mean,
                sd = sd,
                median = median), na.rm = TRUE, 
    .names = "{col}_{fn}"
    )) %>% 
  mutate_if(is.numeric, round, 2)

sum.horm %>% 
  tibble::rowid_to_column("#") %>% 
  kable(caption = "Summary statistics") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), font_size = 10) %>% 
  scroll_box(width = "800px", height = "300px")
```


# Hormone concentrations: log-normal distribution

* Both response variables `cort_ngml` and `oxyt_pgml`have a left skewed frequency distribution, which asks for a log-transformation.

```{r, fig.height=8, out.width="80%"}
p1 <- dat.horm %>%
  ggplot(aes(x = cort_ngml)) +
  geom_histogram(bins = 30, col = "black", fill = "yellow", alpha = 0.3) +
  ggtitle("Cortisol") +
  theme_bw()

p2 <- dat.horm %>% 
  ggplot(aes(x = log(cort_ngml))) +
  geom_histogram(bins = 30, col = "black", fill = "yellow", alpha = 0.3) +
  ggtitle("Log cortisol") +
  theme_bw()

p3 <- dat.horm %>%
  ggplot(aes(x = oxyt_pgml)) +
  geom_histogram(bins = 30, col = "black", fill = "pink", alpha = 0.3) +
  ggtitle("Oxytocin") +
  theme_bw()

p4 <- dat.horm %>% 
  ggplot(aes(x = log(oxyt_pgml))) +
  geom_histogram(bins = 30, col = "black", fill = "pink", alpha = 0.3) +
  ggtitle("Log oxytocin") +
  theme_bw()

patchwork <- p1 + p2 + p3 + p4

patchwork +
  plot_layout(ncol = 2)
```

\ 

# Cortisol analysis

It is not trivial to decide which random intercept and random slopes structure to include in the model. Here we use the function `fe.re.tab()` written by Roger Mundry with following rules.


## Which random slopes to include?

* *Rule 1:* to include a random slope of a **covariate** we need at least three unique values of the covariate per level of the random effect (otherwise the random slope would be **unidentifiable**)
* *Rule 2:* to include random slope of a **factor**, we need at least two observations per level of the random effect (otherwise the random slope would be **unidentifiable**)

To include random slope if the requirement is fullfilled for at least half of the levels of the random effect. The function `fe.re.tab()` determines the number of levels of the random effect per number of unique cases of the fixed effect with **at least two observations**

```{r}
# extract relevant columns, as only complete cases are considered and in this way prevent some unwanted dropping of cases
dat.cort <- dat.horm %>% 
  dplyr::select(cort_ngml_log, context, sex, age.z, time.n.z,
         uniq.id, date, sow, uniq.group)

fe.re.cort <- fe.re.tab(
  fe.model = "cort_ngml_log ~ context + sex + age.z + time.n.z",
  re       = "(1|uniq.id) + (1|sow) + (1|uniq.group) + (1|date)",
  data     = dat.cort)

fe.re.cort$summary
```

\ 

Based on the analysis using the function `fe.re.tab()`, we define following structure of the linear mixed model:

* random intercepts + random slopes for these fixed effects within `date`
  + INCLUDE: `sex`, `time.n.z`
  + EXCLUDE: `context`, `age.z`

* random intercepts + random slopes for these fixed effects within `sow`
  + INCLUDE: `context`, `age.z`, `sex`, `time.n.z`
  + EXCLUDE:  *none*

* random intercepts + random slopes for these fixed effects within `uniq.group`
  + INCLUDE: `context`, `age.z`, `sex`, `time.n.z`
  + EXCLUDE: *none*

* random intercepts + random slopes for these fixed effects within `uniq.id`
  + INCLUDE: `age.z`, `time.n.z`
  + EXCLUDE: `context`, `sex`

\ 

* independent random intercepts **and** random slopes defined in **two separate** $Z$-terms, but **using the same grouping factor $g1$**
  + syntax: `(1 | g1)` + `(0 + z1 | g1)`
  + `(1 | g1)` defines the random intercepts
  + `(0 + z1 | g1)` indicates the random slopes separately, i.e. no random intercepts here
  + an alternative, more compact syntax: `(z1 || g1)`  

## Full model (Cortisol)

### And comparison with null model

* We run the full model with the fixed effects `context`, `sex` and the fixed covariates `age.z` and 2nd order regression of `time.z` AND the random effect structure as derived above
* We compare the full model to the null model, i.e. excluding `context`, `sex` and `age.z`
* We use `anova(mfull, mnull, test="Chisq")`, i.e. compare both models using the Chi-square test. It tests whether reduction in the residual sum of squares are statistically significant or not.

```{r}
# context levels
con.wean <- as.numeric(dat.horm$context==levels(dat.horm$context)[2]) # weaning
con.play <- as.numeric(dat.horm$context==levels(dat.horm$context)[3]) # play
con.sepa <- as.numeric(dat.horm$context==levels(dat.horm$context)[4]) # separation
con.reun <- as.numeric(dat.horm$context==levels(dat.horm$context)[5]) # reunion

# sex levels
sex.male <- as.numeric(dat.horm$sex==levels(dat.horm$sex)[2]) # male piglets

contr = lmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 10000000), calc.derivs = FALSE)

mfull.cort=lme4::lmer(cort_ngml_log ~ 
                     #fixed effects 
                      context                  +
                      sex                      +
                      age.z                    + 
                      time.n.z + I(time.n.z^2) + 
                     #random effects, independent random intercepts and slopes
                      (1+sex.male+time.n.z||date)                                                 +
                      (1+con.wean+con.play+con.sepa+con.reun+age.z+sex.male+time.n.z||sow)        +
                      (1+con.wean+con.play+con.sepa+con.reun+age.z+sex.male+time.n.z||uniq.group) +
                      (1+age.z+time.n.z||uniq.id),
                     #data set
                      data = dat.horm,
                     #final model set REML = TRUE
                      REML = TRUE,
                      control = contr)

mnull.cort=lme4::lmer(cort_ngml_log ~ 
                     #fixed effects
                      time.n.z + I(time.n.z^2) + 
                     #random effects, independent random intercepts and slopes
                      (1+sex.male+time.n.z||date)                                                 +
                      (1+con.wean+con.play+con.sepa+con.reun+age.z+sex.male+time.n.z||sow)        +
                      (1+con.wean+con.play+con.sepa+con.reun+age.z+sex.male+time.n.z||uniq.group) +
                      (1+age.z+time.n.z||uniq.id),
                     #data set
                      data = dat.horm,
                     #final model set REML = TRUE
                      REML = TRUE,
                      control = contr)

mcomp.cort <- anova(mfull.cort, mnull.cort, test = "Chisq")
mcomp.cort
```

* The full and the null model for cortisol differ with $\chi^2 = $ `round(mcomp.cort$Chisq[2], 2)`, $df = $ `mcomp.cort$Df[2]`, $p = $ `mcomp.cort$`Pr(>Chisq)`[2]`


### Stability test of full model

* We apply the function `glmm.model.stab()` written by Roger Mundry that determines the stability of GLMMs by excluding levels of random effects, one at a time

```{r, eval = FALSE}
mfull.cort.stab <- glmm.model.stab(model.res = mfull.cort,
                                   contr = NULL,
                                   para  = FALSE,
                                   data  = NULL)

round(mfull.cort.stab$summary[, -1], 3)
is.re=grepl(x=rownames(mfull.cort.stab$summary), pattern="@")

m.stab.plot(mfull.cort.stab$summary[!is.re, -1])
```

\ 

### Performance of full model

* We apply the function `check_model()` of the R package `performance` to present the performance of the full model.
* We calculate the variance inflation factor (VIF) to check for multicollinearity of the full model using the function `check_collinearity`.

```{r}
performance::check_model(mfull.cort)

performance::check_collinearity(mfull.cort)
```

\ 

### Fixed effects

* We re-fit the full model with the R package `lmerTest` to obtain *p* values
* To obtain the F-values of the fixed effects we use `anova(..., type = 'II')` to test for each main effect after the other main effect (default is `type ='III'`)
* We use the `summary()`function to get the estimates and standard errors of the fixed effects

```{r}
library(lmerTest)

mfull.cort.p=lmerTest::lmer(cort_ngml_log ~ 
                     #fixed effects 
                      context                  +
                      sex                      +
                      age.z                    + 
                      time.n.z + I(time.n.z^2) + 
                     #random effects, independent random intercepts and slopes
                      (1+sex.male+time.n.z||date)                                                 +
                      (1+con.wean+con.play+con.sepa+con.reun+age.z+sex.male+time.n.z||sow)        +
                      (1+con.wean+con.play+con.sepa+con.reun+age.z+sex.male+time.n.z||uniq.group) +
                      (1+age.z+time.n.z||uniq.id),
                     #data set
                      data = dat.horm,
                     #final model set REML = TRUE
                      REML = TRUE,
                      control = contr)

# ANOVA table
anova(mfull.cort.p, type='II')

# estimates of the fixed effects
round(summary(mfull.cort.p)$coefficients,3)
```

\ 

## Viz full model (Cortisol)

We use the `emmeans` package to calculate estimated marginal means. We then plot the emmeans of the main effects and show the post hoc comparisons (Tukey adjustment) among groups in the plot. We use the compact letter display to vizualise post hoc results, whereby two emmeans sharing one or more grouping symbols are not “significantly” different. These is generated using the `multcomp::cld()` function.

The degrees of freedom are fractional: that is due to the fact that whole-plot and subplot variations are combined when standard errors are estimated. Different degrees-of-freedom methods are available. By default, the Kenward-Roger method is used in the `emmeans` package. We may specify a different degrees-of-freedom method via the optional argument `lmer.df`. The Satterthwaite method is implemented in the `lmerTest` package. Note that, with this method, not only are the degrees of freedom slightly different, but so are the standard errors. That is because the Kenward-Roger method also entails making a bias adjustment to the covariance matrix of the fixed effects; that is the principal difference between the methods.

```{r}
# this gives the same results as using contrast()
# use Satterthwaite method for degree of freedoms
mfull.cort.em <- emmeans(mfull.cort, pairwise ~ context, 
                         adjust = "tukey", 
                         lmer.df = "satterthwaite")

# show the contrasts
mfull.cort.em$contrasts

# cld = compact letter display
mfull.cort.cld <- multcomp::cld(mfull.cort.em$emmeans, Letters=letters) 

#reorder rows
mfull.cort.cld <- tibble(mfull.cort.cld) %>% 
  mutate(context   = factor(context,
                            levels=c("Baseline","Weaning","Play",
                                     "Separation","Reunion"))) %>% 
  arrange(context)

# remove whitespace in string
mfull.cort.cld$.group <- str_replace_all(mfull.cort.cld$.group, fixed(" "), "")

mfull.cort.cld
```

\ 

```{r}
# x axis
xlabs.cort <- c("Baseline \n(n=255)","Weaning \n(n=61)","Play \n(n=58)","Separation \n(n=75)","Reunion \n(n=75)")

# cortisol plot
p1 <- dat.horm %>% 
  ggplot() +
  geom_boxplot(aes(x = context, y = log(cort_ngml)), outlier.shape = NA, width = 0.5) +
  geom_jitter(aes(x = context, y = log(cort_ngml), col = context), 
              size = 1.5, width = 0.15, alpha = 0.5) +
  scale_colour_manual("Social context",
                      values = c("grey60", "firebrick", "navy", "firebrick", "navy"))+
  scale_y_continuous(lim = c(0, 4), breaks = seq(0, 4, 1)) +
  scale_x_discrete(labels= xlabs.cort) +
  geom_point(data=mfull.cort.cld, col="black", size=3,
             aes(x=as.numeric(context)+0.35, y=emmean)) +
  geom_errorbar(data=mfull.cort.cld, col="black", width=0.1,
                aes(x=as.numeric(context)+0.35,
                    ymin=emmean - SE, ymax=emmean + SE)) +
  geom_text(data=mfull.cort.cld, col="black",
            aes(y=emmean, x=as.numeric(context)+0.45, label=.group, hjust = 0)) +
  labs(x = "",
       y = c(expression(paste("Log concentration cortisol (ng ", ml^-1, ")")))) +
  my_theme +
  theme(legend.position = "none")

# helper table + plot for legend
a <-dat.horm %>% 
  dplyr::filter(context == "Baseline" | context == "Weaning" | context == "Play")
  
p2 <-   ggplot(data = a, aes(x = age, y = cort_ngml, color = context)) +
           geom_point() +
           scale_colour_manual("Social context",
                      breaks=c('Neutral', 'Negative', 'Positive'),
                      values=c('Neutral'='grey60', 'Negative'='firebrick', 'Positive'='navy'))+
           my_theme

legend <- get_legend(p2)

plot_grid(p1, legend, ncol=2, rel_widths = c(4, 1))
```

\ 

```{r, include = FALSE}
png("./FIG/cortisol_fig2.png",
     #compression = "lzw", type = "win",
     family = "Arial", units = "mm",
     width = 180, height = 100, pointsize = 10, res = 300)

plot_grid(p1, legend, ncol=2, rel_widths = c(4, 1))

dev.off()

tiff("./FIG/cortisol_fig2.tiff",
     compression = "lzw", type = "win",
     family = "Arial", units = "mm",
     width = 180, height = 100, pointsize = 10, res = 600)

plot_grid(p1, legend, ncol=2, rel_widths = c(4, 1))

dev.off()
```

\ 

```{r, include = FALSE}
# x axis
xlabs.cort <- c("Baseline \n(n=255)","Weaning \n(n=61)","Play \n(n=58)","Separation \n(n=75)","Reunion \n(n=75)")

# cortisol plot
p1.poster <- dat.horm %>% 
  ggplot() +
  geom_boxplot(aes(x = context, y = log(cort_ngml)), outlier.shape = NA, width = 0.5) +
  geom_jitter(aes(x = context, y = log(cort_ngml), col = context), 
              size = 2.5, width = 0.15, alpha = 0.5) +
  scale_colour_manual("Social context",
                      values = c("grey60", "firebrick", "navy", "firebrick", "navy"))+
  scale_y_continuous(lim = c(0, 4), breaks = seq(0, 4, 1)) +
  scale_x_discrete(labels= xlabs.cort, expand = expansion(add =0.8)) +
  geom_point(data=mfull.cort.cld, col="black", size=4,
             aes(x=as.numeric(context)+0.35, y=emmean)) +
  geom_errorbar(data=mfull.cort.cld, col="black", width=0.1,
                aes(x=as.numeric(context)+0.35,
                    ymin=emmean - SE, ymax=emmean + SE)) +
  geom_text(data=mfull.cort.cld, col="black", size = 18/.pt,
            aes(y=emmean, x=as.numeric(context)+0.45, label=.group, hjust = 0)) +
  labs(x = "",
       y = c(expression(paste("Log concentration cortisol (ng ", ml^-1, ")")))) +
  my_theme_poster +
  theme(legend.position = "none")

# helper table + plot for legend
a <-dat.horm %>% 
  dplyr::filter(context == "Baseline" | context == "Weaning" | context == "Play")
  
p2.poster <-   ggplot(data = a, aes(x = age, y = cort_ngml, color = context)) +
  geom_point(size = 4) +
  scale_colour_manual("Social context",
                      breaks=c('Neutral', 'Negative', 'Positive'),
                      values=c('Neutral'='grey60', 'Negative'='firebrick', 'Positive'='navy'))+
  my_theme_poster +
  guides(colour = guide_legend(byrow = TRUE))

legend.poster <- get_legend(p2.poster)

png("./FIG/poster/cortisol_fig2_poster.png",
     #compression = "lzw", type = "win",
     family = "Arial", units = "mm",
     width = 270, height = 150, pointsize = 20, res = 300)

plot_grid(p1.poster, legend.poster, ncol=2, rel_widths = c(4, 1))

dev.off()
```

\ 

# Oxytocin analysis

It is not trivial to decide which random intercept and random slopes structure to include in the model. Here we use the function `fe.re.tab()` written by Roger Mundry with following rules.

## Which random slopes to include?

* *Rule 1:* to include a random slope of a **covariate** we need at least three unique values of the covariate per level of the random effect (otherwise the random slope would be **unidentifiable**)
* *Rule 2:* to include random slope of a **factor**, we need at least two observations per level of the random effect (otherwise the random slope would be **unidentifiable**)

To include random slope if the requirement is fullfilled for at least half of the levels of the random effect. The function `fe.re.tab()` determines the number of levels of the random effect per number of unique cases of the fixed effect with **at least two observations**

```{r}
# extract relevant columns, as only complete cases are considered and in this way prevent some unwanted dropping of cases
dat.oxyt <- dat.horm %>% 
  dplyr::select(oxyt_pgml_log, context, sex, age.z, time.n.z,
         uniq.id, date, sow, uniq.group)

fe.re.oxyt <- fe.re.tab(
  fe.model = "oxyt_pgml_log ~ context + sex + age.z + time.n.z",
  re       = "(1|uniq.id) + (1|sow) + (1|uniq.group) + (1|date)",
  data     = dat.oxyt)

fe.re.oxyt$summary
```

\ 

Based on the analysis using the function `fe.re.tab()`, we define following structure of the linear mixed model for oxytocin, **which is the same as for cortisol**:

* random intercepts + random slopes for these fixed effects within `date`
  + INCLUDE: `sex`, `time.n.z`
  + EXCLUDE: `context`, `age.z`

* random intercepts + random slopes for these fixed effects within `sow`
  + INCLUDE: `context`, `age.z`, `sex`, `time.n.z`
  + EXCLUDE:  *none*

* random intercepts + random slopes for these fixed effects within `uniq.group`
  + INCLUDE: `context`, `age.z`, `sex`, `time.n.z`
  + EXCLUDE: *none*

* random intercepts + random slopes for these fixed effects within `uniq.id`
  + INCLUDE: `age.z`, `time.n.z`
  + EXCLUDE: `context`, `sex`

\ 

* independent random intercepts **and** random slopes defined in **two separate** $Z$-terms, but **using the same grouping factor $g1$**
  + syntax: `(1 | g1)` + `(0 + z1 | g1)`
  + `(1 | g1)` defines the random intercepts
  + `(0 + z1 | g1)` indicates the random slopes separately, i.e. no random intercepts here
  + an alternative, more compact syntax: `(z1 || g1)`

## Full model (Oxytocin)

### And comparison with null model

* We run the full model with the fixed effects `context`, `sex` and the fixed covariates `age.z` and 2nd order regression of `time.z` AND the random effect structure as derived above
* We compare the full model to the null model, i.e. excluding `context`, `sex` and `age.z`
* We use `anova(mfull, mnull, test="Chisq")`, i.e. compare both models using the Chi-square test. It tests whether reduction in the residual sum of squares are statistically significant or not.

```{r}
# context levels
con.wean <- as.numeric(dat.horm$context==levels(dat.horm$context)[2]) # weaning
con.play <- as.numeric(dat.horm$context==levels(dat.horm$context)[3]) # play
con.sepa <- as.numeric(dat.horm$context==levels(dat.horm$context)[4]) # separation
con.reun <- as.numeric(dat.horm$context==levels(dat.horm$context)[5]) # reunion

# sex levels
sex.male <- as.numeric(dat.horm$sex==levels(dat.horm$sex)[2]) # male piglets

contr = lmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 10000000), calc.derivs = FALSE)

mfull.oxyt=lme4::lmer(oxyt_pgml_log ~ 
                     #fixed effects 
                      context                  +
                      sex                      +
                      age.z                    + 
                      time.n.z + I(time.n.z^2) + 
                     #random effects, independent random intercepts and slopes
                      (1+sex.male+time.n.z||date)                                                 +
                      (1+con.wean+con.play+con.sepa+con.reun+age.z+sex.male+time.n.z||sow)        +
                      (1+con.wean+con.play+con.sepa+con.reun+age.z+sex.male+time.n.z||uniq.group) +
                      (1+age.z+time.n.z||uniq.id),
                     #data set
                      data = dat.horm,
                     #final model set REML = TRUE
                      REML = TRUE,
                      control = contr)

mnull.oxyt=lme4::lmer(oxyt_pgml_log ~ 
                     #fixed effects
                      time.n.z + I(time.n.z^2) + 
                     #random effects, independent random intercepts and slopes
                      (1+sex.male+time.n.z||date)                                                 +
                      (1+con.wean+con.play+con.sepa+con.reun+age.z+sex.male+time.n.z||sow)        +
                      (1+con.wean+con.play+con.sepa+con.reun+age.z+sex.male+time.n.z||uniq.group) +
                      (1+age.z+time.n.z||uniq.id),
                     #data set
                      data = dat.horm,
                     #final model set REML = TRUE
                      REML = TRUE,
                      control = contr)

mcomp.oxyt <- anova(mfull.oxyt, mnull.oxyt, test = "Chisq")
mcomp.oxyt
```

\ 

* The full and the null model for cortisol differ with $\chi^2 = $ `round(mcomp.oxyt$Chisq[2], 2)`, $df = $ `mcomp.oxyt$Df[2]`, $\p = $ ` mcomp.oxyt$`Pr(>Chisq)`[2]`


### Stability test of full model

* We apply the function `glmm.model.stab()` written by Roger Mundry that determines the stability of GLMMs by excluding levels of random effects, one at a time

```{r, eval = FALSE}
mfull.oxyt.stab <- glmm.model.stab(model.res = mfull.oxyt,
                                   contr = NULL,
                                   para  = FALSE,
                                   data  = NULL)

round(mfull.oxyt.stab$summary[, -1], 3)
is.re=grepl(x=rownames(mfull.oxyt.stab$summary), pattern="@")

m.stab.plot(mfull.oxyt.stab$summary[!is.re, -1])
```

\ 

### Performance of full model

* We apply the function `check_model()` of the R package `performance` to present the performance of the full model.
* We calculate the variance inflation factor (VIF) to check for multicollinearity of the full model using the function `check_collinearity`.

```{r}
performance::check_model(mfull.oxyt)

performance::check_collinearity(mfull.oxyt)
```

\ 

### Fixed effects

* We re-fit the full model with the R package `lmerTest` to obtain *p* values
* To obtain the F-values of the fixed effects we use `anova(..., type = 'II')` to test for each main effect after the other main effect (default is `type ='III'`)
* We use the `summary()`function to get the estimates and standard errors of the fixed effects

```{r}
library(lmerTest)

mfull.oxyt.p=lmerTest::lmer(oxyt_pgml_log ~ 
                     #fixed effects 
                      context                  +
                      sex                      +
                      age.z                    + 
                      time.n.z + I(time.n.z^2) + 
                     #random effects, independent random intercepts and slopes
                      (1+sex.male+time.n.z||date)                                                 +
                      (1+con.wean+con.play+con.sepa+con.reun+age.z+sex.male+time.n.z||sow)        +
                      (1+con.wean+con.play+con.sepa+con.reun+age.z+sex.male+time.n.z||uniq.group) +
                      (1+age.z+time.n.z||uniq.id),
                     #data set
                      data = dat.horm,
                     #final model set REML = TRUE
                      REML = TRUE,
                      control = contr)

# ANOVA table
anova(mfull.oxyt.p, type='II')

# estimates of the fixed effects
round(summary(mfull.oxyt.p)$coefficients,3)
```

\ 

## Viz oxytocin full model

We use the `emmeans` package to calculate estimated marginal means (also known as lsmeans). We then plot the emmeans of the main effects and show the post hoc comparisons (Tukey adjustment) among groups in the plot. We use the compact letter display to vizualise post hoc results, whereby two emmeans sharing one or more grouping symbols are not “significantly” different. These is generated using the `multcomp::cld()` function.

The degrees of freedom are fractional: that is due to the fact that whole-plot and subplot variations are combined when standard errors are estimated. Different degrees-of-freedom methods are available. By default, the Kenward-Roger method is used in the `emmeans` package. We may specify a different degrees-of-freedom method via the optional argument `lmer.df`. The Satterthwaite method is implemented in the `lmerTest` package. Note that, with this method, not only are the degrees of freedom slightly different, but so are the standard errors. That is because the Kenward-Roger method also entails making a bias adjustment to the covariance matrix of the fixed effects; that is the principal difference between the methods.

Why do we plot emmeans and not ordinary means? Estimated marginal means are what the ordinary means would be, had the experiment been balanced. Emmeans are derived from the model. A different model for the same data may lead to different emmeans.

```{r}
# this gives the same results as using contrast()
# use Satterthwaite method for degree of freedoms
mfull.oxyt.em <- emmeans(mfull.oxyt, pairwise ~ context, 
                         adjust = "tukey", 
                         lmer.df = "satterthwaite")

# show the contrasts
mfull.oxyt.em$contrasts

# cld = compact letter display
mfull.oxyt.cld <- multcomp::cld(mfull.oxyt.em$emmeans, Letters=letters) 

#reorder rows
mfull.oxyt.cld <- tibble(mfull.oxyt.cld) %>% 
  mutate(context   = factor(context,
                            levels=c("Baseline","Weaning","Play",
                                     "Separation","Reunion"))) %>% 
  arrange(context)

# remove whitespace in string
mfull.oxyt.cld$.group <- str_replace_all(mfull.oxyt.cld$.group, fixed(" "), "")

mfull.oxyt.cld
```

\ 

```{r}
# x axis
xlabs.oxyt <- c("Baseline \n(n=191)","Weaning \n(n=51)","Play \n(n=70)","Separation \n(n=73)","Reunion \n(n=72)")

# oxytocin plot
p1 <- dat.horm %>% 
  ggplot() +
  geom_boxplot(aes(x = context, y = log(oxyt_pgml)), outlier.shape = NA, width = 0.5) +
  geom_jitter(aes(x = context, y = log(oxyt_pgml), col = context), 
              size = 1.5, width = 0.15, alpha = 0.5) +
  scale_colour_manual("Social context",
                      values = c("grey60", "firebrick", "navy", "firebrick", "navy"))+
  scale_y_continuous(lim = c(0, 6), breaks = seq(0, 6, 1)) +
  scale_x_discrete(labels= xlabs.oxyt) +
  labs(x = "",
       y = c(expression(paste("Log concentration oxytocin (pg ", ml^-1, ")")))) +
  my_theme +
  theme(legend.position = "none")


# helper table + plot for legend
a <-dat.horm %>% 
  dplyr::filter(context == "Baseline" | context == "Weaning" | context == "Play")
  
p2 <-   ggplot(data = a, aes(x = age, y = cort_ngml, color = context)) +
           geom_point() +
           scale_colour_manual("Social context",
                      breaks=c('Neutral', 'Negative', 'Positive'),
                      values=c('Neutral'='grey60', 'Negative'='firebrick', 'Positive'='navy'))+
           my_theme

legend <- get_legend(p2)

plot_grid(p1, legend, ncol=2, rel_widths = c(4, 1))
```

\ 

```{r, include = FALSE}
png("./FIG/oxytocin_fig3.png",
     #compression = "lzw", type = "win",
     family = "Arial", units = "mm",
     width = 180, height = 100, pointsize = 10, res = 300)

plot_grid(p1, legend, ncol=2, rel_widths = c(4, 1))

dev.off()

tiff("./FIG/oxytocin_fig3.tiff",
     compression = "lzw", type = "win",
     family = "Arial", units = "mm",
     width = 180, height = 100, pointsize = 10, res = 600)

plot_grid(p1, legend, ncol=2, rel_widths = c(4, 1))

dev.off()
```

\ 

```{r, include = FALSE}
# x axis
xlabs.oxyt <- c("Baseline \n(n=191)","Weaning \n(n=51)","Play \n(n=70)","Separation \n(n=73)","Reunion \n(n=72)")

# oxytocin plot
p1.poster <- dat.horm %>% 
  ggplot() +
  geom_boxplot(aes(x = context, y = log(oxyt_pgml)), outlier.shape = NA, width = 0.5) +
  geom_jitter(aes(x = context, y = log(oxyt_pgml), col = context), 
              size = 2.5, width = 0.15, alpha = 0.5) +
  scale_colour_manual("Social context",
                      values = c("grey60", "firebrick", "navy", "firebrick", "navy"))+
  scale_y_continuous(lim = c(0, 6), breaks = seq(0, 6, 1)) +
  scale_x_discrete(labels= xlabs.oxyt, expand = expansion(add =0.8)) +
  labs(x = "",
       y = c(expression(paste("Log concentration oxytocin (pg ", ml^-1, ")")))) +
  my_theme_poster +
  theme(legend.position = "none")


# helper table + plot for legend
a <-dat.horm %>% 
  dplyr::filter(context == "Baseline" | context == "Weaning" | context == "Play")
  
p2.poster <-   ggplot(data = a, aes(x = age, y = cort_ngml, color = context)) +
  geom_point(size = 4) +
  scale_colour_manual("Social context",
                      breaks=c('Neutral', 'Negative', 'Positive'),
                      values=c('Neutral'='grey60', 'Negative'='firebrick', 'Positive'='navy'))+
  my_theme_poster +
  guides(colour = guide_legend(byrow = TRUE))

legend.poster <- get_legend(p2.poster)

png("./FIG/poster/oxytocin_fig3_poster.png",
     #compression = "lzw", type = "win",
     family = "Arial", units = "mm",
     width = 270, height = 150, pointsize = 20, res = 300)

plot_grid(p1.poster, legend.poster, ncol=2, rel_widths = c(4, 1))

dev.off()
```

\ 

# Session Info

```{r}
sessionInfo()
```
